/*
  (c) 2012, Janusz Dalecki
 */
package handlers;

import io.*;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;

import org.apache.log4j.Logger;

/**
 * Uses non-blocking operations to read and write from a socket. Internally,
 * this class uses a selector to receive read and write events from the
 * underlying socket.
 * 
 * Methods on this class should be called only by the selector's thread
 * (including the constructor). If necessary, use Selector.invokeLater() to
 * dispatch a invocation to the selector's thread.
 * 
 * @author Janusz Dalecki
 */
final public class HeaderBodyPacketChannel implements ReadWriteSelectorHandler,
		IPacketChannel {
	static Logger logger = Logger.getLogger("HeaderBodyPacketChannel.class");

	public static final int HEADER_SIZE = 10;
	/** The associated selector. */
	protected final SelectorThread selector;
	/** The socket where read and write operations are performed. */
	private final SocketChannel sc;
	/** Used for reading from the socket. */
	private ByteBuffer inBuffer;
	/**
	 * The buffer with the packet currently being sent. This class can only send
	 * one packet at a time, there are no queueing mechanisms.
	 */
	private ByteBuffer outBuffer = null;

	private String channelID = "UNKNOWN";
	
  /**
	 * Object interested in the events generated by this class. It is notified
	 * whenever an error occurs or a packet is read.
	 */
	private final PacketChannelListener listener;

	byte soh = 0;
	byte magic = 0;
	int bodySize = -1;
	String command = "";

	private boolean headerRead = false;
	private boolean bodyRead = false;

	/**
	 * Creates and initializes a new instance. 'Read' interest is enabled by the
	 * constructor, so callers should be ready to start receiving packets.
	 * 
	 * @param socketChannel
	 *            Socket to be wrapped.
	 * @param selector
	 *            Selector to be used for managing IO events.
	 * @param listener
	 *            Object to receive the callbacks.
	 * @throws IOException
	 */
	public HeaderBodyPacketChannel(SocketChannel socketChannel,
			SelectorThread selector, PacketChannelListener listener)
			throws IOException {

		this.selector = selector;
		this.sc = socketChannel;
		this.listener = listener;

		// Creates the reading buffer
		// The size is the HEADER_SIZE.
		inBuffer = ByteBuffer.allocateDirect(HEADER_SIZE);

		// Registers with read interest.
		// JD comment - 0 is a no interest at all, SelectionKey.OP_READ is 1
		selector.registerChannelNow(sc, 0, this);
	}

	/**
	 * Activates reading from the socket. This method is non-blocking.
	 */
	public void resumeReading() throws IOException {
		reactivateReading();
	}

	public void close() {
		try {
			sc.close();
		} catch (IOException e) {
			// Ignore
		}
	}

	/**
	 * Reads from the socket into the internal buffer. This method should be
	 * called only from the SelectorThread class.
	 */
	public void handleRead() {
		try {
			// Reads from the socket
			// Returns -1 if it has reached end-of-stream
			int readBytes = sc.read(inBuffer);
			// End of stream???
			if (readBytes == -1) {
				// End of stream. Closing channel...
				close();
				listener.socketDisconnected(this);
				return;
			}

			// Anything else to read?
			if (inBuffer.hasRemaining()) {
				// There was nothing to read or there is still data to be filled
				// in. Shouldn't happen often, but
				// it is not an error, we can deal with it. Ignore this event
				// and reactivate reading.
				reactivateReading();
				return;
			} else {
				logger.info("Reading message from="
						+ sc.socket().getRemoteSocketAddress());
				if (!headerRead) {
					int bodySize = parseHeader();
					if (bodySize != 0) {
						inBuffer = ByteBuffer.allocateDirect(bodySize);
						reactivateReading();
					} else {
						// No body required
						inBuffer = null;
						bodyRead = true;
						// There is no body but the message is complete.
						// Processes it.
						listener.packetArrived(this, inBuffer);
						// Prepare for the next header
						reset();
					}
					headerRead = true;
				} else {
					// There is some body data in the buffer. Processes it.
					inBuffer.flip();
					listener.packetArrived(this, inBuffer);
					// Prepare for the next header
					reset();
				}
			}
		} catch (IOException ex) {
			// Serious error. Close socket.
			listener.socketException(this, ex);
			close();
		}
	}

	/**
	 * Disable interest in reading.
	 * 
	 * @throws IOException
	 */
	public void disableReading() throws IOException {
		selector.removeChannelInterestNow(sc, SelectionKey.OP_READ);
	}

  /**
   * Disable interest in writing.
   * 
   * @throws IOException
   */
  public void disableWriting() throws IOException {
    selector.removeChannelInterestNow(sc, SelectionKey.OP_WRITE);
  }

	/**
	 * Enables interest in reading.
	 * 
	 * @throws IOException
	 */
	private void reactivateReading() throws IOException {
		selector.addChannelInterestNow(sc, SelectionKey.OP_READ);
	}

	/**
	 * Sends a packet using non-blocking writes. One packet cannot be sent
	 * before the previous one has been dispatched. The caller must ensure this.
	 * 
	 * This class keeps a reference to buffer given as argument while sending
	 * it. So it is important not to change this buffer after calling this
	 * method.
	 * 
	 * @param packet
	 *            The packet to be sent.
	 */
  public void sendPacket(ByteBuffer packet) {
    // keeps a reference to the packet. In production code this should copy
    // the contents of the buffer.
    outBuffer = packet;
    try {
      disableReading();
      requestWrite();
    } catch (IOException ioe) {
      close();
      listener.socketException(this, ioe);
    }
  }

	/**
	 * Activates interest in writing.
	 * 
	 * @throws IOException
	 */
	private void requestWrite() throws IOException {
		selector.addChannelInterestNow(sc, SelectionKey.OP_WRITE);
	}

	/**
	 * Writes to the underlying channel. Non-blocking. This method is called
	 * only from  the SelectorThread class.
	 */
	public void handleWrite() {
		try {
			// Writes to the socket as much as possible. Since this is a
			// non-blocking operation, we don't know in advance how many
			// bytes will actually be written.
			int written = sc.write(outBuffer);
      logger.info("Writing message="+outBuffer+" to="
          + sc.socket().getRemoteSocketAddress());
			
			// Check if there are more to be written.
			if (outBuffer.hasRemaining()) {
				// There is. Reactivate interest in writing. We will try again
				// when the socket is ready.
				requestWrite();
			} else {
				// outBuffer was completely written. Notifies listener
				ByteBuffer sentPacket = outBuffer;
        logger.info("Packet sent to CHANNEL="+getChannelID() + " to user="+ sc.getRemoteAddress()+ " Message=" +outBuffer.toString());
				outBuffer = null;
        reactivateReading();
				listener.packetSent(this, sentPacket);
			}
		} catch (IOException ioe) {
			close();
			listener.socketException(this, ioe);
		}
	}

	public SocketChannel getSocketChannel() {
		return sc;
	}

	public String toString() {
		return "[soh=" + soh
				+ " mgc=" +magic
				+ " bs="+bodySize
				+ " cmd=" +command
				+ " ls="+sc.socket().getLocalAddress()
				+ " rs="+sc.socket().getRemoteSocketAddress()
				+"]"
				;
	}

	private int parseHeader() {
		// Parse the header and return the body size derived from header
		inBuffer.flip();
		soh = inBuffer.get();
		magic = inBuffer.get();

		byte[] buffer = new byte[4];
		inBuffer.get(buffer, 0, 4);
		command = new String(buffer);

		bodySize = inBuffer.getInt();
		logger.info("Header received="+toString());
		return bodySize;
	}

	public void reset() {
		inBuffer = ByteBuffer.allocateDirect(HEADER_SIZE);
		headerRead = false;
		bodyRead = false;
		soh = 0;
		magic = 0;
		command = "";
		bodySize = -1;
	}
	public String getCommand() {
		return command;
	}

  @Override
  public void setChannelID(String id) {
    channelID = id;
  }

  @Override
  public String getChannelID() {
    return channelID;
  }
}